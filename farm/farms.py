import asyncio
import re
import traceback
import types

import async_timeout

import farm.models as models
from backends.flag_submitter import AbstractFlagSubmitter
from farm import defaults
from farm.configurator import Configurator
from farm.exploit_storage import AbstractExploitStorage, OneExploitStorage
from farm.logging import Logger
from farm.storage import AbstractFlagStorage, DirectoryFlagStorage


class Farm:
    def __init__(self,
                 teams: [models.Team],
                 exploit_storage: AbstractExploitStorage,
                 flag_submitter: AbstractFlagSubmitter,
                 flag_storage: AbstractFlagStorage,
                 flag_format: str,
                 round_timeout=None,
                 submitter_sleep=None):
        self.teams = teams
        self.exploit_storage = exploit_storage
        self.flag_submitter = flag_submitter
        self.flag_storage = flag_storage
        self.flag_format = flag_format
        self._flag_re_str = re.compile(flag_format)
        self._flag_re_bytes = re.compile(flag_format.encode())
        self.round_timeout = defaults.ROUND_TIMEOUT if round_timeout is None else round_timeout
        self.submitter_sleep = defaults.SUBMITTER_SLEEP if submitter_sleep is None else submitter_sleep

        self.logger = Logger(self)

    @classmethod
    def create_from_configurator(cls, configurator: Configurator):
        return cls(
            configurator.get_teams(),
            configurator.get_exploit_storage(),
            configurator.get_flag_submitter(),
            configurator.get_flag_storage(),
            configurator.get_flag_format(),
            configurator.get_round_timeout(),
            configurator.get_submitter_sleep(),
        )

    @classmethod
    def debug_exploit(cls, exploit, vulnbox, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()

        configurator = Configurator()
        farm = cls(
            [models.Team('Target', vulnbox)],
            OneExploitStorage(exploit),
            None,
            None,
            configurator.get_flag_format(),
        )
        task = asyncio.wait([farm._run_one_round()], loop=loop)
        loop.run_until_complete(task)

    def run(self, loop=None):
        if loop is None:
            loop = asyncio.get_event_loop()

        task = asyncio.wait([self._run_exploits(), self._run_submitter()], loop=loop)
        loop.run_until_complete(task)

    async def _run_exploits(self):
        round = 0
        while True:
            round += 1
            try:
                self.logger.info('EXPLOITS ROUND %d' % round)
                await self._run_one_round()
            except asyncio.TimeoutError as e:
                # It's ok: just some exploit didn't finish him work
                pass
            except Exception as e:
                self.logger.error('Error occurred while running exploits: %s' % e, e)

    async def _run_one_round(self):
        try:
            exploits = await self.exploit_storage.get_exploits()
        except Exception as e:
            self.logger.error(f'Can\'t get exploits from exploits storage: {e}', e)
            return

        if not exploits:
            # It no exploits loaded sleep self.round_timeout
            await asyncio.sleep(self.round_timeout)
            return

        with async_timeout.timeout(self.round_timeout):
            tasks = []
            for team in self.teams:
                for exploit in exploits:
                    tasks.append(self._run_exploit(team, exploit))

            while tasks:
                done, tasks = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)
                for task in done:
                    exploit_result, exploit_name = await task
                    # TODO (andgein): dump exploit output somewhere
                    flags = self._extract_flags(exploit_result)
                    if len(flags) > 0:
                        self.logger.info('Found flags in exploit output: [%s]' % ", ".join(map(str, flags)))

                        if self.flag_storage is not None:
                            await self.flag_storage.add_flags(flags, exploit_name)

    async def _run_exploit(self, team, exploit):
        exploit_name = str(exploit)
        try:
            self.logger.info(f'Start exploit [{exploit}] on team [{team}]')
            run_attack = exploit.attack(team.vulnbox)
            # In case of async generators (https://www.python.org/dev/peps/pep-0525/) we can't await it, we should
            # iterate over it via `async for` operator
            if isinstance(run_attack, types.AsyncGeneratorType):
                return [data async for data in run_attack], exploit_name

            # Otherwise just await it because `exploit.attack()` is asynchronous function
            return await run_attack, exploit_name
        except Exception as e:
            message = f'Exception on exploit [{exploit}] on team [{team}]: {e}'
            self.logger.warning(message)
            # Duplicate message in exploit's log with stacktrace details and ERROR level
            exploit.logger.error(message + "\n" + traceback.format_exc())
            return '', exploit_name

    def _extract_flags(self, exploit_result):
        if type(exploit_result) in [str, bytes]:
            exploit_result = [exploit_result]

        # TODO (andgein): log which exploit it was
        if not isinstance(exploit_result, (tuple, list, types.GeneratorType)):
            error_message = 'Exploit returned invalid result: %s, should be tuple, list, generator, str or bytes, not %s' % (
                exploit_result, type(exploit_result)
            )
            self.logger.error(error_message)
            return []

        flags = []
        for line in exploit_result:
            if type(line) is bytes:
                line_flags = re.findall(self._flag_re_bytes, line)
            elif type(line) is str:
                line_flags = re.findall(self._flag_re_str, line)
            else:
                self.logger.error(
                    'Exploit returned invalid result in list: %s, should be str or bytes, not %s' % (
                        line,
                        type(line)
                    ))
                line_flags = []
            flags.extend(line_flags)

        return flags

    async def _run_submitter(self):
        while True:
            try:
                flags = await self.flag_storage.get_not_sent_flags()
            except Exception as e:
                self.logger.error(f'Can\'t get not sent flags from storage: {e}', e)
                continue

            if len(flags) > 0:
                self.logger.info(
                    f'Got {len(flags)} not sent flags from flag storage and '
                    f'sending them to checksystem: [{", ".join(f.flag for f in flags)}]'
                )
                try:
                    await self.flag_submitter.send_flags(flags)
                except Exception as e:
                    self.logger.error(f'Can\'t send flags to checksystem: {e}', e)

            await asyncio.sleep(self.submitter_sleep)
